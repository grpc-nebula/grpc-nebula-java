// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc/gcp/handshaker.proto

package io.grpc.alts.internal;

public interface StartServerHandshakeReqOrBuilder extends
    // @@protoc_insertion_point(interface_extends:grpc.gcp.StartServerHandshakeReq)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  java.util.List<java.lang.String>
      getApplicationProtocolsList();
  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  int getApplicationProtocolsCount();
  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  java.lang.String getApplicationProtocols(int index);
  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  com.google.protobuf.ByteString
      getApplicationProtocolsBytes(int index);

  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */
  int getHandshakeParametersCount();
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */
  boolean containsHandshakeParameters(
      int key);
  /**
   * Use {@link #getHandshakeParametersMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
  getHandshakeParameters();
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */
  java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
  getHandshakeParametersMap();
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */

  io.grpc.alts.internal.ServerHandshakeParameters getHandshakeParametersOrDefault(
      int key,
      io.grpc.alts.internal.ServerHandshakeParameters defaultValue);
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */

  io.grpc.alts.internal.ServerHandshakeParameters getHandshakeParametersOrThrow(
      int key);

  /**
   * <pre>
   * Bytes in out_frames returned from the peer's HandshakerResp. It is possible
   * that the peer's out_frames are split into multiple HandshakReq messages.
   * </pre>
   *
   * <code>bytes in_bytes = 3;</code>
   */
  com.google.protobuf.ByteString getInBytes();

  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the client,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
   */
  boolean hasLocalEndpoint();
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the client,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
   */
  io.grpc.alts.internal.Endpoint getLocalEndpoint();
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the client,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
   */
  io.grpc.alts.internal.EndpointOrBuilder getLocalEndpointOrBuilder();

  /**
   * <pre>
   * (Optional) Endpoint information of the remote client, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
   */
  boolean hasRemoteEndpoint();
  /**
   * <pre>
   * (Optional) Endpoint information of the remote client, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
   */
  io.grpc.alts.internal.Endpoint getRemoteEndpoint();
  /**
   * <pre>
   * (Optional) Endpoint information of the remote client, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
   */
  io.grpc.alts.internal.EndpointOrBuilder getRemoteEndpointOrBuilder();

  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the server.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
   */
  boolean hasRpcVersions();
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the server.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
   */
  io.grpc.alts.internal.RpcProtocolVersions getRpcVersions();
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the server.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
   */
  io.grpc.alts.internal.RpcProtocolVersionsOrBuilder getRpcVersionsOrBuilder();
}
